#!/usr/bin/env python

import sys
sys.path.append('../community_networks_analysis')

from misclibs import navigateRoutingTables
from gengraphs import loadGraph
import glob
import json
import networkx as nx

if len(sys.argv) < 3:
    print "This script compares the output of the emulator with a real topology, and "
    print "checks that the routing tables computed by mininet are the same computed"
    print "with networkX using the shortest path method. In case it finds failed nodes"
    print "it checks the routing tables coherently."
    print "usage: ./compare_topologies_recursively.py ",\
            "path_prefix full_topology"
    print "path_prefix is the prefix of the routing table files generated by dummyrouting"
    print "full_topology is the edge file decstibing the original network"
    sys.exit(1)

failedNodes = []

pathPrefix = sys.argv[1]
topoFile = sys.argv[2]
g = loadGraph(topoFile, remap=True)
print g.nodes()

jsonRt = {}
nodeList = set()


# read topology files, populate the global routing table structure
for topoFile in glob.glob(pathPrefix+"*.rt"):
    try:
        f = open(topoFile, "r")
        j = json.load(f)
    except Exception as e:
        print "NOK", str(e)
        sys.exit(1)
    nodeIP = ".".join(j["node"].split(":")[0].split(".")[:3])
    if j["failed"] == True:
        failedNodes.append(nodeIP)
        continue
    rt = j["rt"]
    jsonRt[nodeIP] = {}
    for dest, nh in rt.items():
        shortDest = ".".join(dest.split(".")[:3])
        shortNh = ".".join(nh[0].split(".")[:3])
        jsonRt[nodeIP][shortDest] = [shortNh] + nh[1:]

    nodeList.add(str(nodeIP))

shortedFailedNodes = [int(n.split(".")[-1]) for n in failedNodes]

print "failed nodes", failedNodes, shortedFailedNodes

nl = list(nodeList)
if len(nl) == 0:
    print "NOK: can not read routing tables"
    sys.exit(1)

failedNodesErrors = 0

# check that noone has a route to a failed node:
if failedNodes != []:
    for node in jsonRt:
        if set(jsonRt[node]).intersection(failedNodes):
            failedNodesErrors += 1
            print "node", node, "has a route to a failed node:", failedNodes

print "failed nodes errors:", failedNodesErrors

#for node, rt  in jsonRt.items():
#    if len(rt) != len(nl) - 1:
#        print "node ", node, "misses some routes"
#        print json.dumps(jsonRt, indent=1)
#        sys.exit(1)

#print json.dumps(jsonRt, indent=1)

errors = 0

for fnode in failedNodes:
    f = int(fnode.split(".")[2])
    g.remove_node(f)

# navigate the global routing table and compare the routes with 
# the ones computed on the original graph
for i in range(len(nl)):
    for j in range(i+1, len(nl)):
        sIP = nl[i]
        dIP = nl[j]
        s = int(nl[i].split(".")[2])
        d = int(nl[j].split(".")[2])
        print "== rt ", s, d
        try:
            route = navigateRoutingTables(jsonRt, sIP,
                dIP, [], 0)
        except KeyError as e:
            errors += 1
            print str(e)
            print sIP, jsonRt[sIP]
            print dIP, jsonRt[dIP]
            print "NOK!: there is no route from ", s, "to", d
            continue
        except Exception as e:
            print "Error in navigating the RT"
            print str(e)
            continue
        allRoutes = [p for p in nx.all_shortest_paths(g, s, d)]

        shortedRoute =  [int(r.split(".")[2]) for r in route[0]]

        if shortedRoute not in allRoutes:
            for computedRoute in allRoutes:
                # if the route computed on the full graph includes a failed node
                # we don't raise an error, else we do
                if set(computedRoute).intersection(shortedFailedNodes) != set():
                    continue
                else:
                    print "NOK!: route", shortedRoute, "not in ", allRoutes
                    errors += 1
                    break
        print "OK!: route", shortedRoute, "found in", allRoutes

print "Found ", errors, "errors"





